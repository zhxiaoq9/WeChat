
## 一. FIFO简介
FIFO(first in first out)的中文名称叫先进先出队列，它就像一个单向管道一样，我们可以在其一端写入数据，而在另一端将数据读出。FIFO根据读写时钟是否为同一个时钟可以分为同步FIFO和异步FIFO两种。  
异步FIFO常用作不同时钟域的数据传输，也是电路设计中的难点之一。本系列文章基于Clifford的经典论文介绍异步FIFO的设计方法。

**FIFO常见重要参数**
>宽度：从FIFO中读写数据时的数据位宽(N)  
>深度：FIFO中存储的N比特位宽的数据个数  
>空标志：表示FIFO中的数据已被全部读出，此时不可以再对FIFO进行读操作  
>满标志：表示FIFO没有多余的空间存储新的数据，此时不可以再对FIFO进行写操作  
>几乎空标志：表示FIFO中剩余的数据不多  
>几乎满标志：表示FIFO中的空间快被填满




## 二. 异步FIFO工作原理
![FIFO工作原理](https://raw.githubusercontent.com/zhxiaoq9/WeChat/master/ClassicalCircuitDesign_FIFO/images/FIFOWorkTheory.PNG "图片来自参考文献1")

异步FIFO包含了读(raddr)与写(waddr)指针，读指针在读时钟(rclk)域，写指针在写时钟(wclk)域。其中读指针指向下一个要读数据的地址，写指针指向下一个要写数据的地址。这里以深度为16的FIFO为例介绍FIFO的工作过程，地址位宽为4。

1. 复位：复位时FIFO为空，读写指针同时指向地址0。因为此时FIFO没有数据，所以空标志(EMPTY)置位。  

2. 写：假设此时向FIFO中写入7个数据，那么写指针waddr从0增加到7，而raddr仍然为0。  当向FIFO中写入第一个数据后FIFO就不再为空，因此需要清除EMPTY置位状态。

3. 读：写完7个数据后再将7个数据读出，读指针raddr从0增加到6，此时计算下一个要读取的地址为7，与waddr相等，则判定FIFO为空并将EMPTY置位。
> 细心的你会发现这一步中FIFO是否为空的判断并不像上图所示的那样直接用raddr和waddr比较，而是用raddr的下一个地址和waddr比较。这是因为raddr指向的是当前要读的地址而waddr指向下一个要写的地址。raddr=6时实际上FIFO已经空了。

4. 写：继续向FIFO中写入数据，同时清除EMPTY的置位。当向FIFO中写入15个数据后waddr=6，此时waddr与raddr相等，则判定FIFO已满，满标志FULL置位。
>你会发现其实这时候FIFO并没有满，因为waddr指向的是下一个要写入的地址，waddr=6时此地址中还并没有写入数，造成FIFO空间的浪费。但是这样并不影响FIFO的使用，现实情形中在设计FIFO时也往往会设计的比需要的空间大。而且在之后的设计实例中会发现实际编码中也并不是直接用waddr和raddr比较，而可能是waddr的下一个地址与raddr比较。

从上面的工作原理可以看到，无论FIFO是空还是满，其判断条件都是raddr=waddr，那么我们如何判断到底是空还是满呢？  
>由于FIFO为空是由读操作引起，而FIFO为满是由写操作引起，所以我们可以根据当前是在进行读还是进行写来判断到底是空还是满。同时这也决定了将空信号置位的操作发生在读时钟域，将满信号置位的操作是发生在写时钟域。而清除空信号置位的操作发生在写时钟域，清除满信号置位的操作在读时钟域。

## 三. FIFO设计要点
由FIFO工作原理我们可以发现FIFO设计的几个要点：

* 空满信号的产生  
正确产生空满信号对FIFO工作的稳定性是至关重要的，如果FIFO为空时没有正确产生空信号，继续读FIFO读出的数据就会发生错误，造成下溢。如果FIFO已满而没有产生满信号，则继续写FIFO会将还未读出的有效数据覆盖，造成上溢。

* 异步时钟域信号传输    
判断是否为空时，需要在读时钟域采样写指针(waddr)。但写指针的变化是在写时钟域发生的。同样，判断是否为满时，需要在写时钟域采样读时钟域的读指针(raddr)。这涉及到异步时钟域多比特信号的同步问题。

#### 空满信号的产生  
**判断是否读空或写满有两种方法：**    
**方法1：** 如上所述，raddr=waddr时，通过当前是读操作还是写操作判断。   
**方法2：** 在地址指针上扩展一个比特位，直接通过raddr和waddr的值判断。  
例如在对于深度为16的FIFO，正常读写指针为4比特，但是我们将其扩展为5比特。我们对FIFO所做的操作为：  
   * 写入10个数据：waddr=5'b0_1010, raddr=5'b0_0000
   * 读取10个数据：waddr=5'b0_1010, raddr=5'b0_1010, FIFO空
   * 写入16个数据：waddr=5'b1_1010, raddr=5'b0_1010, FIFO满
   * 读取16个数据：waddr=5'b1_1010, raddr=5'b1_1010, FIFO空   

可以看到当waddr[4]=raddr[4]并且waddr[3:0]=raddr[3:0]时FIFO为空，而当waddr[4]!=raddr[4]并且waddr[3:0]=raddr[3:0]时FIFO为满。我们可以把最高位看做一个标志，当两个地址最高位相同时说明读指针追上了写指针，此时为空；当最高位不同时说明写指针越过FIFO最大地址重新循环了一次，此时为满。
 
#### 异步时钟域信号传输  
异步时钟域信号传输需要特殊处理，否则很可能导致亚稳态的出现导致系统不稳定，跨异步时钟域的信号同步问题的解决方法有：   
* 两级(多级)同步器
* 边沿同步器
* 脉冲同步器
* 结绳法
* 握手协议
* 异步FIFO
>PS:之后会专门推出跨时钟域信号同步的文章。

FIFO设计中常用的是两级同步器，但这种同步器常用来同步单比特信号，而在FIFO设计中我们需要同步的是多比特的地址信号。那怎么样使用两级同步器同步多比特信号呢？  

**1. 首先我们看一下什么是两级同步器**
![两级同步器](https://raw.githubusercontent.com/zhxiaoq9/WeChat/master/ClassicalCircuitDesign_FIFO/images/LevelSyn.PNG "图片来自网络")

上图中，clk1时钟域的寄存器regA_data的输出经过两个clk2时钟域的寄存器后生成了同步后的信号out_data，这就是两级同步器的基本结构。假设clk1中的信号值原本为1'b1，若在clk2时钟的上升沿其值还是1'b1，那么肯定不会产生亚稳态。而如果在clk2的上升沿，其值从1'b1->1'b0，那么可能出现亚稳态导致最后的out_data值不确定。  
总之当两级同步器的输入不变时肯定不会出现亚稳态，而输入变化时则亚稳态会导致同步后的输出不确定。

**2. 直接使用两级同步器同步地址会造成什么问题。**  
假设FIFO深度为16，读地址raddr设置为5比特。如果raddr当前值为5'b0_1111，要将raddr同步到读时钟域需要5个两级同步器。假设在同步时钟的上升沿raddr的值增加1，由5'b0_1111变为5'b1_0000。那么由于5个两级同步器的输入端都发生了变化，那么发生亚稳态时5个输出端的值都不能确定。所以在这一变化中同步后的信号会有2^5=32个可能的值。由于同步后的raddr会与waddr比较用来产生写满信号，所有raddr同步的错误会对FIFO造成致命的影响。

***所以我们不能直接对二进制地址直接进行同步。***  

**3. 使用格雷码进行同步**  
FIFO中不能直接对二进制地址直接进行同步的方法是使用格雷码进行同步。因为格雷码每次只有一个比特发生变化，因此使用两级同步器进行同步时最多只可能有一比特发生错误。下图是一个深度为8的FIFO的格雷码编码情况。

![格雷码](https://raw.githubusercontent.com/zhxiaoq9/WeChat/master/ClassicalCircuitDesign_FIFO/images/GrayCode.PNG "图片来自参考文献1")

上图***左侧***为第二种(论文里把它称为***第二种***)格雷码编码，这是平常我们使用最多的编码形式。对于深度为8的FIFO其变化范围是4'b0000->...->4'b1000。这种编码方式的特点是除了最高位外，其它的位在上半部分(0-7)和下半部分(8-15)是镜像分布的。由于访问存储单元只需要最低3比特，因此会使用格雷码低3比特访问存储器。但是由于其是镜像对称的，所以直接用低3比特访问存储器会发生问题。  
例如，假设读指针为4'b0111，写指针为4'b0100，在写完3'b100储单元后若还想继续写存储器，那么因为格雷码从4'b0100变为4'b1100，而访问存储器只需要使用低3比特，所以下一次写存储器时仍然写的是3'b100。这明显是不正确的。

**所以使用格雷码访问存储器时要保证除了最高位外的其它所有位的变化顺序是一样的。**  

这就有了上图***右侧***编码方式(论文里称为***第一种***编码方式)。对于一个深度为8的FIFO，其编码变化为4'b0000->...->4'b0100->4'b1000->...->4'b1100->4'b0000。可以看出其低3比特是格雷码，且上半部分(0-7)和下半部分(8-15)的变化顺序是一样的。但是整个4比特数据却不是一个真正的格雷码。

>如果要用格雷码访问存储器，必须把第2种格雷码转换为第1种。  
如果要用格雷码比较产生空满信号，则必须使用第2种格雷码。  

第1种格雷码实现结构如下图所示：  
![第1种](https://raw.githubusercontent.com/zhxiaoq9/WeChat/master/ClassicalCircuitDesign_FIFO/images/GrayCodeCounter2.PNG "图片来自参考文献1")

第2种格雷码实现结构如下图所示：  
![第2种](https://raw.githubusercontent.com/zhxiaoq9/WeChat/master/ClassicalCircuitDesign_FIFO/images/GrayCodeCounter1.PNG "图片来自参考文献1")


上面说使用格雷码可以避免二进制码出现的问题，但是问题是使用格雷码仍可能出现1比特的同步错误，**如果这个错误发生了会对FIFO造成影响吗？** ***答案是不会。***  
>假设当前读写地址都为4'b0000,FIFO正常工作空标志应该置位。假设现在对其进行了写操作waddr应该做4'b0000->4'b0001的变化。若此时waddr向读时钟域同步时同步正确，那么久会清除空标志。如果同步错误，即将原本应该同步的4'b0001同步成4'b0000会怎么样呢？答案是空标志位不会清除。因为这造成的唯一结果就是现在FIFO中有数据但空标志位置位了。下次同步正确时此标志位就会被清除。对于满标志位的判断也是类似的。   
**由此可见使用格雷码纵然产生亚稳态也不会对FIFO正常工作造成影响。但是这也是亚稳态只单次发生时的情况，如果连续发生亚稳态的话那FIFO可能就不能正常工作了。**

***使用公式1可以将二进制转换为第二种格雷码，使用公式2可以将第2种格雷码转换为第一种格雷码。***  
> **公式1:** gray = (binary>>1) ^ binary      
**公式2:** gray1[n-2:0] = {gray2[n-1] ^ gray2[n-2], gray2[n-3:0]}


> **参考文献:**
> 1. Clifford E. Cummings, Sunburst Design, Inc. "Simulation and Synthesis Techniques for Asynchronous FIFO Design"
> 2. Clifford E. Cummings, Sunburst Design, Inc., Peter Alfke Xilinx, Inc. "Simulation and Synthesis Techniques for Asynchronous FIFO Design with Asynchronous Pointer Comparisons"